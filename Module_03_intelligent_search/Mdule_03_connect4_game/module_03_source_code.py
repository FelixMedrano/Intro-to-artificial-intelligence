# -*- coding: utf-8 -*-
"""Module_03_Source_Code

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SNr4WcK22QZ8SxmebD3aS5ayaeB_8ybb
"""

import copy
import random
import math
#This code is not my property and belongs to Rishal Hurbans for his " GRokking Ai algorithms" textbook, his the git repo to this and more can be found at
# https://github.com/rishal-hurbans/Grokking-Artificial-Intelligence-Algorithms/tree/master/ch03-intelligent_search/adversarial_search
# the only thing done to this code was implementing it into a single file and changing the design to be more user friendly when run 



print("Hello welcome to a connect 4 game where you will be playing H's and the Ai will be playing A's the point of the game will be to get 4 H's in a row ")
print("in a 5x4 grid. To select a column simply input a number from 0-4. You may win horizontally, vertically, and diagonally.")



# Set the min-max IDs, and pseudo infinity constants
MIN = -1
MAX = 1
INFINITY_POSITIVE = math.inf
INFINITY_NEGATIVE = -math.inf


# This class contains a move and the respective value earned for that move
class Move:

    def __init__(self, move=0, value=0):
        self.move = move
        self.value = value


# Choose a move given a game and a search depth
def choose_move(connect, depth):
    print('Thinking...')
    move_result = False
    # Search for a move until a valid one is found
    while move_result is False:
        move_result = minmax(connect, depth, MAX, 0).move
    return move_result


# Search using the minmax algorithm given a game, search depth, player's ID, and default move
def minmax(connect, depth, min_or_max, move):
    current_score = connect.get_score_for_ai()
    current_is_board_full = connect.is_board_full()
    # Return the default move if it doesn't make sense to search for one
    if current_score != 0 or current_is_board_full or depth == 0:
        return Move(move, current_score)

    best_score = INFINITY_NEGATIVE * min_or_max
    best_max_move = -1
    # Get possible moves given the board size
    moves = random.sample(range(0, connect.board_size_y + 1), connect.board_size_x)
    # Try each move
    for slot in moves:
        neighbor = copy.deepcopy(connect)
        move_outcome = neighbor.play_move(slot)
        if move_outcome:
            # Recursively call minmax for the next state after playing a move
            best = minmax(neighbor, depth - 1, min_or_max * -1, slot)
            # Update the best score and best move
            if (min_or_max == MAX and best.value > best_score) or (min_or_max == MIN and best.value < best_score):
                best_score = best.value
                best_max_move = best.move
    return Move(best_max_move, best_score)
import copy
import random
import math

# Set the min-max IDs, and pseudo infinity constants
MIN = -1
MAX = 1
INFINITY_POSITIVE = math.inf
INFINITY_NEGATIVE = -math.inf


# This class contains a move and the respective value earned for that move
class Move:

    def __init__(self, move=0, value=0):
        self.move = move
        self.value = value


# Choose a move given a game and a search depth
def choose_move(connect, depth):
    print('Thinking...')
    move_result = False
    # Search for a move until a valid one is found
    while move_result is False:
        move_result = minmax(connect, depth, MAX, 0, INFINITY_NEGATIVE, INFINITY_POSITIVE).move
    return move_result
#*************************************************************************************************************************************************

# Search using the minmax algorithm given a game, search depth, player's ID, and default move
def minmax(connect, depth, min_or_max, move, alpha, beta):
    current_score = connect.get_score_for_ai()
    current_is_board_full = connect.is_board_full()
    # Return the default move if it doesn't make sense to search for one
    if current_score != 0 or current_is_board_full or depth == 0:
        return Move(move, current_score)

    best_score = INFINITY_NEGATIVE * min_or_max
    best_max_move = -1
    # Get possible moves given the board size
    moves = random.sample(range(0, connect.board_size_y + 1), connect.board_size_x)
    for slot in moves:
        neighbor = copy.deepcopy(connect)
        move_outcome = neighbor.play_move(slot)
        if move_outcome:
            # Recursively call minmax for the next state after playing a move
            best = minmax(neighbor, depth - 1, min_or_max * -1, slot, alpha, beta)
            # Update the best score and best move, ignore irrelevant scores using alpha beta pruning
            if (min_or_max == MAX and best.value > best_score) or (min_or_max == MIN and best.value < best_score):
                best_score = best.value
                best_max_move = best.move
                if best_score >= alpha:
                    alpha = best_score
                if best_score <= beta:
                    beta = best_score
            if alpha >= beta:
                break
    return Move(best_max_move, best_score)
#***************************************************************************************************************************************
# Symbols to represent human or AI players
PLAYER_HUMAN = 'H'
PLAYER_AI = 'A'
BOARD_EMPTY_SLOT = '_'
WINNING_SEQUENCE_COUNT = 4

# Tuple encoding human player as -1, and AI player as 1
PLAYERS = {PLAYER_HUMAN: -1,
           PLAYER_AI: 1}


# This class encompasses the logic to play a game of connect.
class Connect:

    # The game board is initialized with a board size for x and y.
    def __init__(self, board_size_x=5, board_size_y=4):
        self.board_size_x = board_size_x
        self.board_size_y = board_size_y
        self.player_turn = PLAYERS[PLAYER_AI]
        self.board = self.generate_board(board_size_x, board_size_y)

    # Reset the game with an empty board
    def reset(self):
        self.board = self.generate_board(self.board_size_x, self.board_size_y)

    # Generate an empty board to begin on reset the game
    def generate_board(self, board_size_x, board_size_y):
        board = []
        for x in range(board_size_x):
            row = BOARD_EMPTY_SLOT * board_size_y
            board.append(row)
        return board

    # Print the board to console
    def print_board(self):
        result = ''
        for y in range(0, self.board_size_y):
            for x in range(0, self.board_size_x):
                result += self.board[x][y]
            result += '\n'
        print(result)

    # Print which player's turn it is
    def print_turn(self):
        if self.player_turn == PLAYERS[PLAYER_HUMAN]:
            print('It is Human to play')
        else:
            print('It is AI to play')

    # Determine if the game has a winner between the human and AI
    def has_winner(self):
        if self.has_a_row(PLAYER_HUMAN, WINNING_SEQUENCE_COUNT):
            return "Human won"
        elif self.has_a_row(PLAYER_AI, WINNING_SEQUENCE_COUNT):
            return "AI won"
        return 0

    # Get the score for the AI
    def get_score_for_ai(self):
        if self.has_a_row(PLAYER_HUMAN, 4):
            return -10
        if self.has_a_row(PLAYER_AI, 4):
            return 10
        return 0

    # Determine if a player has a row
    def has_a_row(self, player, row_count):
        for x in range(self.board_size_x):
            for y in range(self.board_size_y):
                if self.has_row_of_x_from_point(player, row_count, x, y, 1, 0):  # Horizontal row
                    return True
                elif self.has_row_of_x_from_point(player, row_count, x, y, 0, 1):  # Vertical row
                    return True
                elif self.has_row_of_x_from_point(player, row_count, x, y, 1, 1):  # Diagonal row
                    return True
        return False

    # Determine if a player has a row given a starting point and offset
    def has_row_of_x_from_point(self, player, row_count, x, y, offset_x, offset_y):
        total = 0
        for i in range(row_count):
            target_x = x + (i * offset_x)
            target_y = y + (i * offset_y)
            if self.is_within_bounds(target_x, target_y):
                if self.board[target_x][target_y] == player:
                    total += 1
        if total == row_count:
            return True
        return False

    # Determine if a specific x,y pair is within bounds of the board
    def is_within_bounds(self, x, y):
        if 0 <= x < self.board_size_x and 0 <= y < self.board_size_y:
            return True
        return False

    # Determine if the entire board is filled with disks
    def is_board_full(self):
        for x in range(self.board_size_x):
            if BOARD_EMPTY_SLOT in self.board[x]:
                return False
        return True

    # Determine if a slot is full
    def is_slot_full(self, slot_number):
        if BOARD_EMPTY_SLOT in self.board[slot_number]:
            return False
        return True

    # Determine if a slot number is empty
    def is_slot_empty(self, slot_number):
        count = 0
        for i in range(self.board_size_y):
            if self.board[slot_number][i] == BOARD_EMPTY_SLOT:
                count += 1
        if count == self.board_size_y:
            return True
        return False

    # Execute a move for a player
    def execute_move(self, player, slot_number):
        row = self.board[slot_number]
        # Place the disk at the bottom if the slot number is empty
        if self.is_slot_empty(slot_number):
            self.board[slot_number] = row[0:self.board_size_y - 1] + player
        else:
            # Place the disk at the next empty slot if the slot number is not empty
            for i in range(0, self.board_size_y - 1):
                if row[i + 1] != BOARD_EMPTY_SLOT:
                    self.board[slot_number] = row[0:i] + player + row[i + 1:]
                    break

    # Execute a move for a player if there's space in the slot and choose the player based on whose turn it is
    def play_move(self, slot):
        if 0 <= slot <= 4:
            if not self.is_slot_full(slot):
                if self.player_turn == PLAYERS[PLAYER_AI]:
                    self.execute_move(PLAYER_AI, slot)
                else:
                    self.execute_move(PLAYER_HUMAN, slot)
                self.player_turn *= -1
                return True
            return False
        return False
#****************************************************************************************************************************************



SEARCH_DEPTH = 10
connect = Connect()
while connect.has_winner() == 0:
    connect.print_turn()
    connect.play_move(choose_move(connect, SEARCH_DEPTH))
    connect.print_board()
    print(connect.has_winner())

    connect.print_turn()
    human_move_result = False
    while human_move_result is False:
        print('Make your move: ')
        human_move = int(input())
        human_move_result = connect.play_move(human_move)
    connect.print_board()
    print(connect.has_winner())