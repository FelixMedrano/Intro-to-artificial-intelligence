# -*- coding: utf-8 -*-
"""a1_medranof_echamberlain.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FMYfAv0p-qX_pR0nPspSRjPnF9R7jrPr

# Assignment 01

Felix Medrano

Emily Chamberlain

06/01/2021

# **Part 1: Shortest Route**
"""

from collections import defaultdict
print('\033[1m'+'***The purpose of this app is to demonstrate different search algorithms that will allow the user')
print('to see the shortest path between 2 cities from a given map. For this assignment the destination')
print('is the city of Bucharest. Algorithms used will include A*, Breadth-first and Depth-first search. ')
print('The output will be the algorithm, itinerary, distances, and total distance*** \n'+'\033[0m')

print('You will be departing to Bucharest, Please indicate which city you would like to start from')



#define a list of cities just for the input 
City_list=["arad","bucharest","craiova", "dobreta","eforie","fagaras","giurgiu", "hirsova","lasi","lugoj",
           "mehadia","neamt","oradea","pitesti","rimnicu vilcea","sibiu","timisoara", "urziceni","vaslui","zerind"]
#make whole code repeatable, will loop unless user says no
Again=True
while Again==True:
  #options for algorithm, will make input capital and compare to this list
  Algorithm_options =["A","B","D"]
  Check=True
  #inquire what city with infinite while loop until user gives appropriate response
  while Check==True :
    #Inquire which city they would like to 
    #prints all the city options
    print('\033[1m'+'Starting points:'+'\033[0m')
    print(*City_list,sep = ', ')
    Depart=input("Please indicate the place to start from the list above: ")
    #make it lowercase to compare to list
    Depart = Depart.lower()
    if Depart in City_list:
      #if input is appropriate jumps out of infinite while loop
      Check=False
    elif Depart =="":
      print("no input detected please try again")
    else:
      print("Sorry we couldn't find "+ Depart + ", please check your spelling and try again")

  #Inquire what algorithm they would like to use with infinite while loop till approriate response given
  Check2=True
  while Check2==True :
    #Inquire which city they would like to 
    print('\033[1m'+'Algorithms:'+'\033[0m')
    #prints all the algorithm options
    print(*Algorithm_options,sep = ',')
    Algorithm=input("Please select an algorithm from the choices A: A*, B: BFS , D: DFS: ")
    Algorithm=Algorithm.capitalize()

    if Algorithm in Algorithm_options:
      #jumps out of while once appropriate response given
      Check2=False
    elif Algorithm=="":
      print("No input detected please try again")
    else:
      print("That is not an option please try again")

  #initializes graph class 
  class Graph():
      def __init__(self):
          
          self.edges = defaultdict(list)
          self.weights = {}
          self.parent = None
          
      #used to add edges
      def add_edge(self, from_node, to_node, weight):
          # Note: assumes edges are bi-directional
          self.edges[from_node].append(to_node)
          self.edges[to_node].append(from_node)
          self.weights[(from_node, to_node)] = weight
          self.weights[(to_node, from_node)] = weight
  #calls class
  graph = Graph()
  #creates edges
  edges = [
      ("bucharest", "giurgiu", 90),
      ("bucharest", "urziceni", 85),
      ("bucharest", "fagaras", 211),
      ("bucharest", "pitesti", 101),
      ("urziceni", "hirsova", 86),
      ("urziceni", "vaslui", 142),
      ("hirsova", "eforie", 86),
      ("vaslui", "lasi", 92),
      ("lasi", "neamt", 87),
      ("rimnicu vilcea", "sibiu", 80),
      ("fagaras", "sibiu", 99),
      ("pitesti", "craiova", 138),
      ("pitesti", "rimnicu vilcea", 97),
      ("craiova", "rimnicu vilcea", 146),
      ("craiova", "dobreta", 120),
      
      ("dobreta","mehadia", 75),
      ("mehadia", "lugoj", 70),
      ("lugoj", "timisoara", 111),
      ("timisoara", "arad", 118),
      ("arad", "zerind", 75),
      ("arad", "sibiu", 140),
      ("zerind", "oradea", 71),
      ("oradea", "sibiu", 151),
  ]
  #fills graph with said edges
  for edge in edges:
      graph.add_edge(*edge)
  #******************************************** A* **************************************************************
  #checks user input for which algorithm they want
  if Algorithm == 'A':

    #this calculates the f(n) with the heuristic value and the distance
    def calculate_cost(graph,origin,target):
      distance_to_root=graph.weights[origin[-1], target]
      cost_to_move= get_move_cost(target)
      return distance_to_root + cost_to_move
    
    #heuristic function
    def get_move_cost(origin):
      if origin=='arad':
        return 366
      if origin=='bucharest':
        return 0
      if origin=='craiova':
        return 160
      if origin=='dobreta':
        return 242
      if origin=='eforie':
        return 161
      if origin=='fagaras':
        return 178
      if origin=='giurgiu':
        return 77
      if origin=='hirsova':
        return 151
      if origin=='lasi':
        return 226
      if origin=='lugoj':
        return 244
      if origin=='mehadia':
        return 241
      if origin=='neamt':
        return 234
      if origin=='oradea':
        return 380
      if origin=='pitesti':
        return 98
      if origin=='rimnicu vilcea':
        return 193
      if origin=='sibiu':
        return 253
      if origin=='timisoara':
        return 329
      if origin=='urziceni':
        return 80
      if origin=='vaslui':
        return 199
      if origin=='zerind':
        return 374

    #main A* fucntion
    def astar(A_graph,start,finish): 

      #initialize variables
      #stack
      aStar=[[start]]

      #keeps track of shortest route
      short=[start]

      #keeps track of what neighbors have been used
      key_node=[]
      #what nodes have been visited
      visit=[]

      #keeps track of the cost of each key node 
      neighbor_cost=[]
      
      count=1

      #while loop will search map
      while aStar:
        #initialize current top of stack and node latest value in current
        current_point=aStar.pop(0)
        node = current_point[-1]

        #checks if node is not in visit if not then initialzes neighbors to all nodes connected to node
        if node not in visit:
          A_neighbors = A_graph.edges[node]
        
        #checks if current point has already been visited
        if current_point not in visit:
          #adds current point to nodes visited list
          visit.append(current_point)

          #returns current point if already in it
          if start == finish:
              return current_point
          
          else:
            #looks at every neighbor in neighbors
            for A_neighbor in A_neighbors:
              #if it hasnt been visited
              if A_neighbor not in visit:
                #keeps track of every node as it gets visited
                key_node.append(A_neighbor)
                #gets the cost of visiting each node
                neighbor_cost.append(calculate_cost(A_graph,current_point,A_neighbor))
                
                #anext gets passed the current point
                anext = list(current_point)
                
                count+=1
                
                #everytime algorithm searches all neighbors
                if count==len(A_neighbors)+1:
                  
                  #finds the minimum value of all the neighbors visited
                  
                  min_value=min(neighbor_cost)
                  min_index=neighbor_cost.index(min_value)
                 
                  #adds shortest neighbor to short list
                  short.append(key_node[min_index])
                  
                  #clears key node for next batch of neighbors and the cost for the list of cost for the next neighbors
                  key_node.clear()
                  neighbor_cost.clear()
                  #resets for next neighbors
                  count=0


                #next neighbors and updates stack
                A_neighbor=short[-1]
                anext.append(A_neighbor)
                aStar.append(anext)
                
                #once the goal is reached
                if A_neighbor==finish:
                  return short
                visit.append(node)
              
    #calls algorithm function        
    astar_path=astar(graph, Depart, 'bucharest')
    astar_path = list(dict.fromkeys(astar_path))

    #design for output
    print("________________________________________________________________________________________________________")
    print("\n\nThe selected Algorithm was A*")
    print("The location selected was: "+"\033[1m"+Depart+"\033[0m"+"\n")
    a=0
    Adistances=[]
    Asum=0
    print("the optimal path found is:\n")
    #gets into a list the distances and the total sum
    while a < len(astar_path)-1:
      Adistances.append(graph.weights[(astar_path[a], astar_path[a+1])])
      Asum=Asum+graph.weights[(astar_path[a], astar_path[a+1])]
      a+=1
    b=0
    #prints everything
    while b < len(astar_path)-1:
      if b==0:
        print("From", "\033[1m",astar_path[b],"\033[0m","to","\033[1m", astar_path[b+1],"\033[0m","which is", "\033[1m",Adistances[b],"\033[0m","Kms away" )
        b+=1 
      if b==len(astar_path)-2:
        print("and finally from ","\033[1m",astar_path[b],"\033[0m", " to","\033[1m",astar_path[b+1],"\033[0m","which is","\033[1m",Adistances[b],"\033[0m","Kms away")
      else:
        print("and then from","\033[1m",astar_path[b],"\033[0m", " to","\033[1m",astar_path[b+1],"\033[0m","which is","\033[1m",Adistances[b],"\033[0m","Kms away")
      b+=1
    print("\n","For a grand total of","\033[1m",Asum,"\033[0m", "Kilometers.","\n\n")

    print("________________________________________________________________________________________________________")
    
    



  #********************************************BFS***************************************************************
  #if user input BFS algorithm/ main algorithm fucntion
  if Algorithm =='B':
    def bfs(graph, end, initial ):
        # shortest paths is a dict of nodes
        # whose value is a tuple of (previous node, weight)
        shortest_paths = {initial: (None,0)}
        current_node = initial
        visited = set()
        
        #goes through paths
        while current_node != end:
            #initiates everything
            visited.add(current_node)
            destinations = graph.edges[current_node]
            weight_to_current_node = shortest_paths[current_node][1]

            #goes through destinations and adds weights and compares weghts
            for next_node in destinations:
                weight = graph.weights[(current_node, next_node)] + weight_to_current_node  
                if next_node not in shortest_paths:    
                  shortest_paths[next_node] = (current_node, weight)
                else:
                    current_shortest_weight = shortest_paths[next_node][1]
                    if current_shortest_weight > weight:
                      shortest_paths[next_node] = (current_node, weight)
            #updates the next destinations
            next_destinations = {node: shortest_paths[node] for node in shortest_paths if node not in visited}


            #checks if route is possible
            if not next_destinations:
                return "Route Not Possible"
            # next node is the destination with the lowest weight
            current_node = min(next_destinations, key=lambda k: next_destinations[k][1])
            
            
        
        # Work back through destinations in shortest path
        path = []
        while current_node is not None:
          
          path.append(current_node)
          next_node = shortest_paths[current_node][0]
          current_node = next_node
        # Reverse path
        path = path[::-1]
        return path

    #call function
    bfs_path=bfs(graph, 'bucharest', Depart)


    #design of output
    print("________________________________________________________________________________________________________")
    print("\n\nThe selected Algorithm was BFS")
    print("The location selected was: "+"\033[1m"+Depart+"\033[0m"+"\n")
    k=0
    distance=[]
    Sum=0
    print("the optimal path found is:\n")

    #gets weights and sums up the weights
    while k < len(bfs_path)-1:
      distance.append(graph.weights[(bfs_path[k], bfs_path[k+1])])
      Sum=Sum+graph.weights[(bfs_path[k], bfs_path[k+1])]
      k+=1
    L=0
    #prints all output
    while L < len(bfs_path)-1:
      if L==0:
        print("From", "\033[1m",bfs_path[L],"\033[0m","to","\033[1m", bfs_path[L+1],"\033[0m","which is", "\033[1m",distance[L],"\033[0m","Kms away" )
        L+=1 
      if L==len(bfs_path)-2:
        print("and finally from ","\033[1m",bfs_path[L],"\033[0m", " to","\033[1m",bfs_path[L+1],"\033[0m","which is","\033[1m",distance[L],"\033[0m","Kms away")
      else:
        print("and then from","\033[1m",bfs_path[L],"\033[0m", " to","\033[1m",bfs_path[L+1],"\033[0m","which is","\033[1m",distance[L],"\033[0m","Kms away")
      L+=1
    print("\n","For a grand total of","\033[1m",Sum,"\033[0m", "Kilometers.","\n\n")

    print("________________________________________________________________________________________________________")

  #**********************************DFS************************************************************************************
  #main DFS algorithm 
  if Algorithm == 'D':
    def dfs(G, root, goal):
      #initializes stack and visited points
      s=[[root]]
      visited_points=[]

      #goes through stack and initializes variables
      while s:
        current=s.pop(0)
        node = current[-1]

        #if node not visited yet
        if node not in visited_points:
            #adds all the nodes connected to the current node
            neighbors = G.edges[node]


            if root == goal:
                return "Quick and easy! start = goal"
            
            #goes through 
            else:
              for neighbor in neighbors:
                #sets next variable
                next = list(current)
                #adds the neighbor
                next.append(neighbor)
                #adds to stack
                s.append(next)
                
                #when done
                if neighbor == goal:
                  return next
            #updates visited
            visited_points.append(node)
            

      return s
    #function call
    dfs_path=dfs(graph, Depart, 'bucharest')

    #design for output

    print("________________________________________________________________________________________________________")
    print("\n\nThe selected Algorithm was DFS")
    print("The location selected was: "+"\033[1m"+Depart+"\033[0m"+"\n")
    i=0
    distances=[]
    sum=0
    print("the optimal path found is:\n")

    #gets weights between edges and sums it up
    while i < len(dfs_path)-1:
      distances.append(graph.weights[(dfs_path[i], dfs_path[i+1])])
      sum=sum+graph.weights[(dfs_path[i], dfs_path[i+1])]
      i+=1
    j=0
    #prints everything in format
    while j < len(dfs_path)-1:
      if j==0:
        print("From", "\033[1m",dfs_path[j],"\033[0m","to","\033[1m", dfs_path[j+1],"\033[0m","which is", "\033[1m",distances[j],"\033[0m","Kms away" )
        j+=1 
      if j==len(dfs_path)-2:
        print("and finally from ","\033[1m",dfs_path[j],"\033[0m", " to","\033[1m",dfs_path[j+1],"\033[0m","which is","\033[1m",distances[j],"\033[0m","Kms away")
      else:
        print("and then from","\033[1m",dfs_path[j],"\033[0m", " to","\033[1m",dfs_path[j+1],"\033[0m","which is","\033[1m",distances[j],"\033[0m","Kms away")
      j+=1
    print("\n","For a grand total of","\033[1m",sum,"\033[0m", "Kilometers.","\n\n")
    print("________________________________________________________________________________________________________")
    


  #*****************PROMPT TO QUIT*******************************************8
  print('\n\n'+'Would you like to try a different city?')
  quit=input("press any button to continue or 0 to quit ")
  print("\n\n\n")
  #makes whole thing quit if user input is 0
  if quit=='0':
    Again=False
    print("\033[1m"+"QUIT"+"\033[0m")
    print("Thank you :)")

  print("\n\n\n")

"""# **Part 2: Adversarial Search**"""

import random
import math
import time
#Part 2: Tic Tac Toe using MINMAX algorithm without alpha-beta pruning:

print('\033[1m'+'This app is a tic-tac-toe game where the user will be playing as the X and the AI will be playing as the O, ' )
print('the player will be given a 3x3 grid with numbers to make their choice from, at the end a winner will be announced or ')
print('there will be a tie, in which case the user will be prompted to play again or to exit the game'+'\033[0m')

#Keep track of whether player wants to go again
again=True
while again==True:
  #get input 
  class Player():
      def __init__(self, letter):
          self.letter = letter

      def get_move(self, game):
          pass

  #get input from human player and where to place
  class HumanPlayer(Player):
      def __init__(self, letter):
          super().__init__(letter)
      #check validity of choice and record what aquare to put it in
      def get_move(self, game):
          valid_square = False
          val = None
          while not valid_square:
              square = input(self.letter + '\'s turn. Input move (0-8): ')
              try:
                  val = int(square)
                  if val not in game.available_moves():
                      raise ValueError
                  valid_square = True
              except ValueError:
                  print('Invalid square. Try again.')
          return val

  #choose from moves and pick one randomly
  class RandomComputerPlayer(Player):
      def __init__(self, letter):
          super().__init__(letter)

      def get_move(self, game):
          square = random.choice(game.available_moves())
          return square

  #minmax algorithm to help make choice
  class SmartComputerPlayer(Player):
      def __init__(self, letter):
          super().__init__(letter)

      def get_move(self, game):
          if len(game.available_moves()) == 9:
              square = random.choice(game.available_moves())
          else:
              square = self.minimax(game, self.letter)['position']
          return square

      def minimax(self, state, player):
          max_player = self.letter  # yourself
          other_player = 'O' if player == 'X' else 'X'

          # first we want to check if the previous move is a winner
          if state.current_winner == other_player:
              return {'position': None, 'score': 1 * (state.num_empty_squares() + 1) if other_player == max_player else -1 * (
                          state.num_empty_squares() + 1)}
          elif not state.empty_squares():
              return {'position': None, 'score': 0}

          if player == max_player:
              best = {'position': None, 'score': -math.inf}  # each score should maximize
          else:
              best = {'position': None, 'score': math.inf}  # each score should minimize
          for possible_move in state.available_moves():
              state.make_move(possible_move, player)
              sim_score = self.minimax(state, other_player)  # simulate a game after making that move

              # undo move
              state.board[possible_move] = ' '
              state.current_winner = None
              sim_score['position'] = possible_move  # this represents the move optimal next move

              if player == max_player:  # X is max player
                  if sim_score['score'] > best['score']:
                      best = sim_score
              else:
                  if sim_score['score'] < best['score']:
                      best = sim_score
          return best


  #create board and make actual game
  class TicTacToe():
      def __init__(self):
          self.board = self.make_board()
          self.current_winner = None

      @staticmethod
      def make_board():
          return [' ' for _ in range(9)]

      def print_board(self):
          for row in [self.board[i*3:(i+1) * 3] for i in range(3)]:
              print('| ' + ' | '.join(row) + ' |')

      @staticmethod
      def print_board_nums():
          # 0 | 1 | 2
          number_board = [[str(i) for i in range(j*3, (j+1)*3)] for j in range(3)]
          for row in number_board:
              print('| ' + ' | '.join(row) + ' |')

      def make_move(self, square, letter):
          if self.board[square] == ' ':
              self.board[square] = letter
              if self.winner(square, letter):
                  self.current_winner = letter
              return True
          return False
      #pay attention to who has won
      def winner(self, square, letter):
          # check the row
          row_ind = math.floor(square / 3)
          row = self.board[row_ind*3:(row_ind+1)*3]
          # print('row', row)
          if all([s == letter for s in row]):
              return True
          col_ind = square % 3
          column = [self.board[col_ind+i*3] for i in range(3)]
          # print('col', column)
          if all([s == letter for s in column]):
              return True
          if square % 2 == 0:
              diagonal1 = [self.board[i] for i in [0, 4, 8]]
              # print('diag1', diagonal1)
              if all([s == letter for s in diagonal1]):
                  return True
              diagonal2 = [self.board[i] for i in [2, 4, 6]]
              # print('diag2', diagonal2)
              if all([s == letter for s in diagonal2]):
                  return True
          return False
      #reads the board
      def empty_squares(self):
          return ' ' in self.board

      def num_empty_squares(self):
          return self.board.count(' ')

      def available_moves(self):
          return [i for i, x in enumerate(self.board) if x == " "]

  #prints everything and calls functions
  def play(game, x_player, o_player, print_game=True):

      if print_game:
          game.print_board_nums()

      letter = 'O'
      while game.empty_squares():
          if letter == 'X':
              square = o_player.get_move(game)
          else:
              square = x_player.get_move(game)
          if game.make_move(square, letter):

              if print_game:
                  print(letter + ' makes a move to square {}'.format(square))
                  game.print_board()
                  print('')

              if game.current_winner:
                  if print_game:
                      print(letter + ' wins!')
                  return letter  # ends the loop and exits the game
              letter = 'X' if letter == 'O' else 'O'  # switches player

          time.sleep(.8)

      if print_game:
          print('It\'s a tie!')



  if __name__ == '__main__':
      x_player = SmartComputerPlayer('O')
      o_player = HumanPlayer('X')
      t = TicTacToe()
      play(t, x_player, o_player, print_game=True)
  print("\033[1m"+"Would you like to try again?"+"\033[0m")
  check=input("press enter to continue or 0 to stop ")
  print("\n\n\n")
  #checkif user wants to play again
  if check=='0':
    again=False
    print("\033[1m"+"GAME OVER!"+"\033[0m")
    print("Thanks for playing :)")

  print("\n\n\n")